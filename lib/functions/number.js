"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var Dimension = require("../tree/dimension"),
    Anonymous = require("../tree/anonymous"),
    mathHelper = require("./math-helper.js");

var minMax = function minMax(isMin, args) {
    args = Array.prototype.slice.call(args);
    switch (args.length) {
        case 0:
            throw { type: "Argument", message: "one or more arguments required" };
    }
    var i,
        j,
        current,
        currentUnified,
        referenceUnified,
        unit,
        unitStatic,
        unitClone,
        order = [],
        // elems only contains original argument values.
    values = {}; // key is the unit.toString() for unified Dimension values,
    // value is the index into the order array.
    for (i = 0; i < args.length; i++) {
        current = args[i];
        if (!(current instanceof Dimension)) {
            if (Array.isArray(args[i].value)) {
                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));
            }
            continue;
        }
        currentUnified = current.unit.toString() === "" && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();
        unit = currentUnified.unit.toString() === "" && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();
        unitStatic = unit !== "" && unitStatic === undefined || unit !== "" && order[0].unify().unit.toString() === "" ? unit : unitStatic;
        unitClone = unit !== "" && unitClone === undefined ? current.unit.toString() : unitClone;
        j = values[""] !== undefined && unit !== "" && unit === unitStatic ? values[""] : values[unit];
        if (j === undefined) {
            if (unitStatic !== undefined && unit !== unitStatic) {
                throw { type: "Argument", message: "incompatible types" };
            }
            values[unit] = order.length;
            order.push(current);
            continue;
        }
        referenceUnified = order[j].unit.toString() === "" && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();
        if (isMin && currentUnified.value < referenceUnified.value || !isMin && currentUnified.value > referenceUnified.value) {
            order[j] = current;
        }
    }
    if (order.length == 1) {
        return order[0];
    }
    args = order.map(function (a) {
        return a.toCSS(this.context);
    }).join(this.context.compress ? "," : ", ");
    return new Anonymous((isMin ? "min" : "max") + "(" + args + ")");
};
exports.default = {
    min: function min() {
        return minMax(true, arguments);
    },
    max: function max() {
        return minMax(false, arguments);
    },
    convert: function convert(val, unit) {
        return val.convertTo(unit.value);
    },
    pi: function pi() {
        return new Dimension(Math.PI);
    },
    mod: function mod(a, b) {
        return new Dimension(a.value % b.value, a.unit);
    },
    pow: function pow(x, y) {
        if (typeof x === "number" && typeof y === "number") {
            x = new Dimension(x);
            y = new Dimension(y);
        } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {
            throw { type: "Argument", message: "arguments must be numbers" };
        }

        return new Dimension(Math.pow(x.value, y.value), x.unit);
    },
    percentage: function percentage(n) {
        var result = mathHelper._math(function (num) {
            return num * 100;
        }, '%', n);

        return result;
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mdW5jdGlvbnMvbnVtYmVyLmpzIl0sIm5hbWVzIjpbIkRpbWVuc2lvbiIsInJlcXVpcmUiLCJBbm9ueW1vdXMiLCJtYXRoSGVscGVyIiwibWluTWF4IiwiaXNNaW4iLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJsZW5ndGgiLCJ0eXBlIiwibWVzc2FnZSIsImkiLCJqIiwiY3VycmVudCIsImN1cnJlbnRVbmlmaWVkIiwicmVmZXJlbmNlVW5pZmllZCIsInVuaXQiLCJ1bml0U3RhdGljIiwidW5pdENsb25lIiwib3JkZXIiLCJ2YWx1ZXMiLCJpc0FycmF5IiwidmFsdWUiLCJwdXNoIiwiYXBwbHkiLCJ0b1N0cmluZyIsInVuZGVmaW5lZCIsInVuaWZ5IiwibWFwIiwiYSIsInRvQ1NTIiwiY29udGV4dCIsImpvaW4iLCJjb21wcmVzcyIsIm1pbiIsImFyZ3VtZW50cyIsIm1heCIsImNvbnZlcnQiLCJ2YWwiLCJjb252ZXJ0VG8iLCJwaSIsIk1hdGgiLCJQSSIsIm1vZCIsImIiLCJwb3ciLCJ4IiwieSIsInBlcmNlbnRhZ2UiLCJuIiwicmVzdWx0IiwiX21hdGgiLCJudW0iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsWUFBWUMsUUFBUSxtQkFBUixDQUFoQjtBQUFBLElBQ0lDLFlBQVlELFFBQVEsbUJBQVIsQ0FEaEI7QUFBQSxJQUVJRSxhQUFhRixRQUFRLGtCQUFSLENBRmpCOztBQUlBLElBQUlHLFNBQVMsU0FBVEEsTUFBUyxDQUFVQyxLQUFWLEVBQWlCQyxJQUFqQixFQUF1QjtBQUNoQ0EsV0FBT0MsTUFBTUMsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCSixJQUEzQixDQUFQO0FBQ0EsWUFBT0EsS0FBS0ssTUFBWjtBQUNJLGFBQUssQ0FBTDtBQUFRLGtCQUFNLEVBQUVDLE1BQU0sVUFBUixFQUFvQkMsU0FBUyxnQ0FBN0IsRUFBTjtBQURaO0FBR0EsUUFBSUMsQ0FBSjtB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Y2tELENBQWQsQ0FBSjtBQUNILFNBSEQsTUFHTyxJQUFJLEVBQUVELGFBQWFqRCxTQUFmLEtBQTZCLEVBQUVrRCxhQUFhbEQsU0FBZixDQUFqQyxFQUE0RDtBQUMvRCxrQkFBTSxFQUFFWSxNQUFNLFVBQVIsRUFBb0JDLFNBQVMsMkJBQTdCLEVBQU47QUFDSDs7QUFFRCxlQUFPLElBQUliLFNBQUosQ0FBYzRDLEtBQUtJLEdBQUwsQ0FBU0MsRUFBRXhCLEtBQVgsRUFBa0J5QixFQUFFekIsS0FBcEIsQ0FBZCxFQUEwQ3dCLEVBQUU5QixJQUE1QyxDQUFQO0FBQ0gsS0F6Qlc7QUEwQlpnQyxnQkFBWSxvQkFBVUMsQ0FBVixFQUFhO0FBQ3JCLFlBQUlDLFNBQVNsRCxXQUFXbUQsS0FBWCxDQUFpQixVQUFTQyxHQUFULEVBQWM7QUFDeEMsbUJBQU9BLE1BQU0sR0FBYjtBQUNILFNBRlksRUFFVixHQUZVLEVBRUxILENBRkssQ0FBYjs7QUFJQSxlQUFPQyxNQUFQO0FBQ0g7QUFoQ1csQyIsImZpbGUiOiJudW1iZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGltZW5zaW9uID0gcmVxdWlyZShcIi4uL3RyZWUvZGltZW5zaW9uXCIpLFxuICAgIEFub255bW91cyA9IHJlcXVpcmUoXCIuLi90cmVlL2Fub255bW91c1wiKSxcbiAgICBtYXRoSGVscGVyID0gcmVxdWlyZShcIi4vbWF0aC1oZWxwZXIuanNcIik7XG5cbnZhciBtaW5NYXggPSBmdW5jdGlvbiAoaXNNaW4sIGFyZ3MpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgc3dpdGNoKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsIG1lc3NhZ2U6IFwib25lIG9yIG1vcmUgYXJndW1lbnRzIHJlcXVpcmVkXCIgfTtcbiAgICB9XG4gICAgdmFyIGksIGosIGN1cnJlbnQsIGN1cnJlbnRVbmlmaWVkLCByZWZlcmVuY2VVbmlmaWVkLCB1bml0LCB1bml0U3RhdGljLCB1bml0Q2xvbmUsXG4gICAgICAgIG9yZGVyICA9IFtdLCAvLyBlbGVtcyBvbmx5IGNvbnRhaW5zIG9yaWdpbmFsIGFyZ3VtZW50IHZhbHVlcy5cbiAgICAgICAgdmFsdWVzID0ge307IC8vIGtleSBpcyB0aGUgdW5pdC50b1N0cmluZygpIGZvciB1bmlmaWVkIERpbWVuc2lvbiB2YWx1ZXMsXG4gICAgLy8gdmFsdWUgaXMgdGhlIGluZGV4IGludG8gdGhlIG9yZGVyIGFycmF5LlxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBhcmdzW2ldO1xuICAgICAgICBpZiAoIShjdXJyZW50IGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1tpXS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcmdzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzW2ldLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VW5pZmllZCA9IGN1cnJlbnQudW5pdC50b1N0cmluZygpID09PSBcIlwiICYmIHVuaXRDbG9uZSAhPT0gdW5kZWZpbmVkID8gbmV3IERpbWVuc2lvbihjdXJyZW50LnZhbHVlLCB1bml0Q2xvbmUpLnVuaWZ5KCkgOiBjdXJyZW50LnVuaWZ5KCk7XG4gICAgICAgIHVuaXQgPSBjdXJyZW50VW5pZmllZC51bml0LnRvU3RyaW5nKCkgPT09IFwiXCIgJiYgdW5pdFN0YXRpYyAhPT0gdW5kZWZpbmVkID8gdW5pdFN0YXRpYyA6IGN1cnJlbnRVbmlmaWVkLnVuaXQudG9TdHJpbmcoKTtcbiAgICAgICAgdW5pdFN0YXRpYyA9IHVuaXQgIT09IFwiXCIgJiYgdW5pdFN0YXRpYyA9PT0gdW5kZWZpbmVkIHx8IHVuaXQgIT09IFwiXCIgJiYgb3JkZXJbMF0udW5pZnkoKS51bml0LnRvU3RyaW5nKCkgPT09IFwiXCIgPyB1bml0IDogdW5pdFN0YXRpYztcbiAgICAgICAgdW5pdENsb25lID0gdW5pdCAhPT0gXCJcIiAmJiB1bml0Q2xvbmUgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQudW5pdC50b1N0cmluZygpIDogdW5pdENsb25lO1xuICAgICAgICBqID0gdmFsdWVzW1wiXCJdICE9PSB1bmRlZmluZWQgJiYgdW5pdCAhPT0gXCJcIiAmJiB1bml0ID09PSB1bml0U3RhdGljID8gdmFsdWVzW1wiXCJdIDogdmFsdWVzW3VuaXRdO1xuICAgICAgICBpZiAoaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodW5pdFN0YXRpYyAhPT0gdW5kZWZpbmVkICYmIHVuaXQgIT09IHVuaXRTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICB0aHJvd3sgdHlwZTogXCJBcmd1bWVudFwiLCBtZXNzYWdlOiBcImluY29tcGF0aWJsZSB0eXBlc1wiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbdW5pdF0gPSBvcmRlci5sZW5ndGg7XG4gICAgICAgICAgICBvcmRlci5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVmZXJlbmNlVW5pZmllZCA9IG9yZGVyW2pdLnVuaXQudG9TdHJpbmcoKSA9PT0gXCJcIiAmJiB1bml0Q2xvbmUgIT09IHVuZGVmaW5lZCA/IG5ldyBEaW1lbnNpb24ob3JkZXJbal0udmFsdWUsIHVuaXRDbG9uZSkudW5pZnkoKSA6IG9yZGVyW2pdLnVuaWZ5KCk7XG4gICAgICAgIGlmICggaXNNaW4gJiYgY3VycmVudFVuaWZpZWQudmFsdWUgPCByZWZlcmVuY2VVbmlmaWVkLnZhbHVlIHx8XG4gICAgICAgICAgICAhaXNNaW4gJiYgY3VycmVudFVuaWZpZWQudmFsdWUgPiByZWZlcmVuY2VVbmlmaWVkLnZhbHVlKSB7XG4gICAgICAgICAgICBvcmRlcltqXSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yZGVyLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBvcmRlclswXTtcbiAgICB9XG4gICAgYXJncyA9IG9yZGVyLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50b0NTUyh0aGlzLmNvbnRleHQpOyB9KS5qb2luKHRoaXMuY29udGV4dC5jb21wcmVzcyA/IFwiLFwiIDogXCIsIFwiKTtcbiAgICByZXR1cm4gbmV3IEFub255bW91cygoaXNNaW4gPyBcIm1pblwiIDogXCJtYXhcIikgKyBcIihcIiArIGFyZ3MgKyBcIilcIik7XG59O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgICBtaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1pbk1heCh0cnVlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWF4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtaW5NYXgoZmFsc2UsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBjb252ZXJ0OiBmdW5jdGlvbiAodmFsLCB1bml0KSB7XG4gICAgICAgIHJldHVybiB2YWwuY29udmVydFRvKHVuaXQudmFsdWUpO1xuICAgIH0sXG4gICAgcGk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oTWF0aC5QSSk7XG4gICAgfSxcbiAgICBtb2Q6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24oYS52YWx1ZSAlIGIudmFsdWUsIGEudW5pdCk7XG4gICAgfSxcbiAgICBwb3c6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gbmV3IERpbWVuc2lvbih4KTtcbiAgICAgICAgICAgIHkgPSBuZXcgRGltZW5zaW9uKHkpO1xuICAgICAgICB9IGVsc2UgaWYgKCEoeCBpbnN0YW5jZW9mIERpbWVuc2lvbikgfHwgISh5IGluc3RhbmNlb2YgRGltZW5zaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiBcIkFyZ3VtZW50XCIsIG1lc3NhZ2U6IFwiYXJndW1lbnRzIG11c3QgYmUgbnVtYmVyc1wiIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihNYXRoLnBvdyh4LnZhbHVlLCB5LnZhbHVlKSwgeC51bml0KTtcbiAgICB9LFxuICAgIHBlcmNlbnRhZ2U6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRoSGVscGVyLl9tYXRoKGZ1bmN0aW9uKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bSAqIDEwMDtcbiAgICAgICAgfSwgJyUnLCBuKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuIl19